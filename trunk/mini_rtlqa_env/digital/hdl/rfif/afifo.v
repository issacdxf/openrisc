// ********************************************************/
// Generated by gen_fifo.pl on Mon Oct 21 16:28:12 2002
// ********************************************************/

//
// 256 words deep asynchronous FIFO
//

// if define RTL_FPGA, code use for FPGA sythsis; or use for ASIC



`timescale 1ns/10ps
//fifo 256x8
`ifdef  RTL_FPGA
module afifo_fpga(
`else
module afifo(
`endif
// write side
  //input
  clk_wr,
  rst_wr,
  syn_rst_wr,
  fifo_wr,
  fifo_din,
  wptr_wr,             //WPTR write signal
  wptr_din,            //WPTR data in signal
  //output
  fifo_full,
  wptr_dout,           //WPTR data out signal
  in_status,

// read side
  //input
  clk_rd,
  rst_rd,
  syn_rst_rd,
  fifo_rd,
  rptr_wr,             //RPTR write signal
  rptr_din,            //RPTR data in signal
  //output
  fifo_dout,
  fifo_empty,
  rptr_dout,           //RPTR data out signal
  out_status

//error flag
//  ferr
);

input         clk_wr;
input         rst_wr;
input         syn_rst_wr;

input         fifo_wr;
input   [7:0] fifo_din;
input         wptr_wr;
input   [7:0] wptr_din;
output        fifo_full;
output  [7:0] wptr_dout;
output  [8:0] in_status;

input         clk_rd;
input         rst_rd;
input         syn_rst_rd;
input         fifo_rd;
input         rptr_wr;
input   [7:0] rptr_din;


output  [7:0] fifo_dout;
output        fifo_empty;
output  [7:0] rptr_dout;
output  [8:0] out_status;

//output        ferr;


reg    [8:0] in_status;
reg    [8:0] out_status;

reg    [8:0] fifo_wptr;
reg    [8:0] fifo_wptr_syn1;
reg    [8:0] fifo_wptr_syn;
wire   [8:0] fifo_wptr_bin;

wire   [8:0] fifo_wptr_syn_bin;

reg    [8:0] fifo_rptr;
reg    [8:0] fifo_rptr_syn1;
reg    [8:0] fifo_rptr_syn;
wire   [8:0] fifo_rptr_bin;

wire   [8:0] fifo_rptr_syn_bin;



/*
wire         fifo_wr_avail = fifo_wr & ~(ferr | fifo_full);
wire         wptr_wr_avail = wptr_wr & ~ferr;
wire         fifo_rd_avail = fifo_rd & ~(ferr | fifo_empty);
wire         rptr_wr_avail = rptr_wr & ~ferr;
*/


assign  fifo_full  = (in_status  == 9'b1_0000_0000);
assign  fifo_empty = (out_status == 9'b0_0000_0000);

assign  wptr_dout = fifo_wptr_bin[7:0];
assign  rptr_dout = fifo_rptr_bin[7:0];



  always @( fifo_wptr_bin or fifo_rptr_syn_bin )
    begin
      if ( fifo_wptr_bin[8] == fifo_rptr_syn_bin[8] )
          in_status = fifo_wptr_bin - fifo_rptr_syn_bin;
      else
          in_status = {1'b1, fifo_wptr_bin[7:0]} - {1'b0,fifo_rptr_syn_bin[7:0]};
    end


  always @( fifo_rptr_bin or fifo_wptr_syn_bin )
    begin
      if ( fifo_wptr_syn_bin[8] == fifo_rptr_bin[8] )
          out_status = fifo_wptr_syn_bin - fifo_rptr_bin;
      else
          out_status = {1'b1,fifo_wptr_syn_bin[7:0]} - {1'b0,fifo_rptr_bin[7:0]};
    end


gray2bin  u0_gray2bin(
     .gray       (fifo_wptr),
     .bin        (fifo_wptr_bin)
     );


gray2bin  u1_gray2bin(
     .gray       (fifo_wptr_syn),
     .bin        (fifo_wptr_syn_bin)
     );


gray2bin  u2_gray2bin(
     .gray       (fifo_rptr),
     .bin        (fifo_rptr_bin)
     );


gray2bin  u3_gray2bin(
     .gray       (fifo_rptr_syn),
     .bin        (fifo_rptr_syn_bin)
     );



  always @( posedge clk_wr or posedge rst_wr)
    begin
      if (rst_wr)
        begin
          fifo_rptr_syn1 <= 9'h000;
          fifo_rptr_syn  <= 9'h000;
        end
      else
        begin
          fifo_rptr_syn1 <= fifo_rptr;
          fifo_rptr_syn  <= fifo_rptr_syn1;
        end
    end

  always @( posedge clk_rd or posedge rst_rd)
    begin
      if (rst_rd)
        begin
          fifo_wptr_syn1 <= 9'h000;
          fifo_wptr_syn  <= 9'h000;
        end
      else
        begin
          fifo_wptr_syn1 <= fifo_wptr;
          fifo_wptr_syn  <= fifo_wptr_syn1;
        end
    end



// gray counter -- wptr
reg   [8:0] next_fifo_wptr_bin;
wire  [8:0] next_fifo_wptr;

always @ (fifo_wptr_bin or wptr_wr or wptr_din)
  begin
    if (wptr_wr)
      next_fifo_wptr_bin = {1'b0, wptr_din};
    else
      next_fifo_wptr_bin = fifo_wptr_bin + 1;
  end

bin2gray  u0_bin2gray(
     .bin        (next_fifo_wptr_bin),
     .gray       (next_fifo_wptr)
     );




// gray counter -- rptr
reg   [8:0] next_fifo_rptr_bin;
wire  [8:0] next_fifo_rptr;

always @ (fifo_rptr_bin or rptr_wr or rptr_din)
  begin
    if (rptr_wr)
      next_fifo_rptr_bin = {1'b0, rptr_din};
    else
      next_fifo_rptr_bin = fifo_rptr_bin + 1;
  end

bin2gray  u1_bin2gray(
     .bin        (next_fifo_rptr_bin),
     .gray       (next_fifo_rptr)
     );



always @( posedge clk_wr or posedge rst_wr)
  begin
    if ( rst_wr )
        fifo_wptr <= 9'h000;
    else if ( syn_rst_wr )
        fifo_wptr <= 9'h000;
    else if ( fifo_wr || wptr_wr )
        fifo_wptr <= next_fifo_wptr;
  end


always @( posedge clk_rd or posedge rst_rd)
  begin
    if ( rst_rd )
        fifo_rptr <= 9'h000;
    else if ( syn_rst_rd)
        fifo_rptr <= 9'h000;
    else if (fifo_rd || rptr_wr)
        fifo_rptr <= next_fifo_rptr;
  end



/*
reg          ferr_wr;
reg          ferr_rd;

always @( posedge clk_wr or posedge rst_wr)
  begin
    if ( rst_wr )
        ferr_wr <= 1'b0;
    else if ( syn_rst_wr )
        ferr_wr <= 1'b0;
    else if ( fifo_full && fifo_wr)
        ferr_wr <= 1'b1;
  end


always @( posedge clk_rd or posedge rst_rd)
  begin
    if ( rst_rd )
        ferr_rd <= 1'b0;
    else if ( syn_rst_rd )
        ferr_rd <= 1'b0;
    else if (fifo_empty && fifo_rd)
        ferr_rd <= 1'b1;
  end


assign  ferr = ferr_wr | ferr_rd;
*/



// mem write address
wire   [7:0] fifo_wptr_bin_index;
assign  fifo_wptr_bin_index = fifo_wptr_bin[7:0];

// mem read address
wire   [7:0] fifo_rptr_bin_index;
assign  fifo_rptr_bin_index = fifo_rptr_bin[7:0];



`ifdef  RTL_FPGA
//SRAM model generate by Xilinx
//8 bits x 256
sram2p_256x8   u_sram2p_256x8 (
   .clkb         (clk_wr),
   .enb          (!fifo_wr),
   .addrb        (fifo_wptr_bin_index),     // write address of sdram, from 0 to 31
   .dinb         (fifo_din),		            // data input to sdram
   .web          (!fifo_wr),

   .douta        (fifo_dout),		            // data output from sdram
   .clka         (clk_rd),
   .ena          (!fifo_rd	),	        // stall signal, sdram stall in high
   .addra        (fifo_rptr_bin_index)	  // read address of sdram, from 0 to 31
   				                            // sdram will continuous output data when stall pull LOW.
);
`else
//SRAM model generate by Artisan
//8 bits x 256
RF2SHD256X8   u_RF2SHD256X8 (
   .QA           (fifo_dout),		            // data output from sdram
   .AA           (fifo_rptr_bin_index),	  // read address of sdram, from 0 to 31
   .CLKA         (clk_rd),
   .CENA         (!fifo_rd	),	        // stall signal, sdram stall in high

   .AB           (fifo_wptr_bin_index),   // write address of sdram, from 0 to 31
   .DB           (fifo_din),		            // data input to sdram
   .CLKB         (clk_wr),
   .CENB         (!fifo_wr)
   				                          // sdram will continuous output data when stall pull LOW.
);
`endif



endmodule


